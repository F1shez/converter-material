
#define STANDARD
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float specularValue;
uniform float opacity;

varying vec3 vViewPosition;

#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
	#define saturate(a) clamp(a, 0.0, 1.0)
#endif

#define whiteComplement(a) (1.0 - saturate(a))
float pow2(const in float x) { return x * x; }
vec3 pow2(const in vec3 x) { return x * x; }
float pow3(const in float x) { return x * x * x; }
float pow4(const in float x)
{
	float x2 = x * x;
	return x2 * x2;
}
float max3(const in vec3 v) { return max(max(v.x, v.y), v.z); }
float average(const in vec3 v) { return dot(v, vec3(0.3333333)); }
highp float rand(const in vec2 uv)
{
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength(vec3 v) { return length(v); }
#else
	float precisionSafeLength(vec3 v)
	{
		float maxComponent = max3(abs(v));
		return length(v / maxComponent) * maxComponent;
	}
#endif
struct IncidentLight
{
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight
{
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection(in vec3 dir, in mat4 matrix)
{
	return normalize((matrix * vec4(dir, 0.0)).xyz);
}
vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix)
{
	return normalize((vec4(dir, 0.0) * matrix).xyz);
}
mat3 transposeMat3(const in mat3 m)
{
	mat3 tmp;
	tmp[0] = vec3(m[0].x, m[1].x, m[2].x);
	tmp[1] = vec3(m[0].y, m[1].y, m[2].y);
	tmp[2] = vec3(m[0].z, m[1].z, m[2].z);
	return tmp;
}
float luminance(const in vec3 rgb)
{
	const vec3 weights = vec3(0.2126729, 0.7151522, 0.0721750);
	return dot(weights, rgb);
}
bool isPerspectiveMatrix(mat4 m)
{
	return m[2][3] == -1.0;
}
vec2 equirectUv(in vec3 dir)
{
	float u = atan(dir.z, dir.x) * RECIPROCAL_PI2 + 0.5;
	float v = asin(clamp(dir.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
	return vec2(u, v);
}
vec3 BRDF_Lambert(const in vec3 diffuseColor)
{
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick(const in vec3 f0, const in float f90, const in float dotVH)
{
	float fresnel = exp2((-5.55473 * dotVH - 6.98316) * dotVH);
	return f0 * (1.0 - fresnel) + (f90 * fresnel);
}
float F_Schlick(const in float f0, const in float f90, const in float dotVH)
{
	float fresnel = exp2((-5.55473 * dotVH - 6.98316) * dotVH);
	return f0 * (1.0 - fresnel) + (f90 * fresnel);
} // validated
vec3 packNormalToRGB(const in vec3 normal)
{
	return normalize(normal) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal(const in vec3 rgb)
{
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;
const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256., 256.);
const vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA(const in float v)
{
	vec4 r = vec4(fract(v * PackFactors), v);
	r.yzw -= r.xyz * ShiftRight8;
	return r * PackUpscale;
}
float unpackRGBAToDepth(const in vec4 v)
{
	return dot(v, UnpackFactors);
}
vec2 packDepthToRG(in highp float v)
{
	return packDepthToRGBA(v).yx;
}
float unpackRGToDepth(const in highp vec2 v)
{
	return unpackRGBAToDepth(vec4(v.xy, 0.0, 0.0));
}
vec4 pack2HalfToRGBA(vec2 v)
{
	vec4 r = vec4(v.x, fract(v.x * 255.0), v.y, fract(v.y * 255.0));
	return vec4(r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half(vec4 v)
{
	return vec2(v.x + (v.y / 255.0), v.z + (v.w / 255.0));
}
float viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far)
{
	return (viewZ + near) / (near - far);
}
float orthographicDepthToViewZ(const in float depth, const in float near, const in float far)
{
	return depth * (near - far) - near;
}
float viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far)
{
	return ((near + viewZ) * far) / ((far - near) * viewZ);
}
float perspectiveDepthToViewZ(const in float depth, const in float near, const in float far)
{
	return (near * far) / ((far - near) * depth - far);
}
#ifdef DITHERING
	vec3 dithering(vec3 color)
	{
		float grid_position = rand(gl_FragCoord.xy);
		vec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);
		dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);
		return color + dither_shift_RGB;
	}
#endif
#if defined(USE_COLOR_ALPHA)
	varying vec4 vColor;
#elif defined(USE_COLOR)
	varying vec3 vColor;
#endif
#if defined(USE_UV) || defined(USE_ANISOTROPY)
	varying vec2 vUv;
#endif

#ifdef USE_MAP
	varying vec2 vMapUv;
#endif

#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif

#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif

#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif

#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif

varying vec2 vNormalMapUv;

#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif

varying vec2 vRoughnessMapUv;

uniform sampler2D specularMap;

uniform sampler2D glossinessMap;

uniform sampler2D map;

#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D(vec2 value)
	{
		return fract(1.0e4 * sin(17.0 * value.x + 0.1 * value.y) * (0.1 + abs(sin(13.0 * value.y + value.x))));
	}
	float hash3D(vec3 value)
	{
		return hash2D(vec2(hash2D(value.xy), value.z));
	}
	float getAlphaHashThreshold(vec3 position)
	{
		float maxDeriv = max(
		length(dFdx(position.xyz)),
		length(dFdy(position.xyz)));
		float pixScale = 1.0 / (ALPHA_HASH_SCALE * maxDeriv);
		vec2 pixScales = vec2(
		exp2(floor(log2(pixScale))),
		exp2(ceil(log2(pixScale))));
		vec2 alpha = vec2(
		hash3D(floor(pixScales.x * position.xyz)),
		hash3D(floor(pixScales.y * position.xyz)));
		float lerpFactor = fract(log2(pixScale));
		float x = (1.0 - lerpFactor) * alpha.x + lerpFactor * alpha.y;
		float a = min(lerpFactor, 1.0 - lerpFactor);
		vec3 cases = vec3(
		x * x / (2.0 * a * (1.0 - a)),
		(x - 0.5 * a) / (1.0 - a),
		1.0 - ((1.0 - x) * (1.0 - x) / (2.0 * a * (1.0 - a))));
		float threshold = (x < (1.0 - a))
		? ((x < a) ? cases.x : cases.y)
		: cases.z;
		return clamp(threshold, 1.0e-6, 1.0);
	}
#endif
#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif
#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif
#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif

#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace(vec3 direction)
	{
		vec3 absDirection = abs(direction);
		float face = -1.0;
		if (absDirection.x > absDirection.z)
		{
			if (absDirection.x > absDirection.y)
			face = direction.x > 0.0 ? 0.0 : 3.0;
			else
			face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		else
		{
			if (absDirection.z > absDirection.y)
			face = direction.z > 0.0 ? 2.0 : 5.0;
			else
			face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV(vec3 direction, float face)
	{
		vec2 uv;
		if (face == 0.0)
		{
			uv = vec2(direction.z, direction.y) / abs(direction.x);
		}
		else if (face == 1.0)
		{
			uv = vec2(-direction.x, -direction.z) / abs(direction.y);
		}
		else if (face == 2.0)
		{
			uv = vec2(-direction.x, direction.y) / abs(direction.z);
		}
		else if (face == 3.0)
		{
			uv = vec2(-direction.z, direction.y) / abs(direction.x);
		}
		else if (face == 4.0)
		{
			uv = vec2(-direction.x, direction.z) / abs(direction.y);
		}
		else
		{
			uv = vec2(direction.x, direction.y) / abs(direction.z);
		}
		return 0.5 * (uv + 1.0);
	}
	vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt)
	{
		float face = getFace(direction);
		float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
		mipInt = max(mipInt, cubeUV_minMipLevel);
		float faceSize = exp2(mipInt);
		highp vec2 uv = getUV(direction, face) * (faceSize - 2.0) + 1.0;
		if (face > 2.0)
		{
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * (exp2(CUBEUV_MAX_MIP) - faceSize);
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT(envMap, uv, vec2(0.0), vec2(0.0)).rgb;
		#else
			return texture2D(envMap, uv).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 -2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 -1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip(float roughness)
	{
		float mip = 0.0;
		if (roughness >= cubeUV_r1)
		{
			mip = (cubeUV_r0 - roughness) * (cubeUV_m1 - cubeUV_m0) / (cubeUV_r0 - cubeUV_r1) + cubeUV_m0;
		}
		else if (roughness >= cubeUV_r4)
		{
			mip = (cubeUV_r1 - roughness) * (cubeUV_m4 - cubeUV_m1) / (cubeUV_r1 - cubeUV_r4) + cubeUV_m1;
		}
		else if (roughness >= cubeUV_r5)
		{
			mip = (cubeUV_r4 - roughness) * (cubeUV_m5 - cubeUV_m4) / (cubeUV_r4 - cubeUV_r5) + cubeUV_m4;
		}
		else if (roughness >= cubeUV_r6)
		{
			mip = (cubeUV_r5 - roughness) * (cubeUV_m6 - cubeUV_m5) / (cubeUV_r5 - cubeUV_r6) + cubeUV_m5;
		}
		else
		{
			mip = -2.0 * log2(1.16 * roughness);
		}
		return mip;
	}
	vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness)
	{
		float mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);
		float mipF = fract(mip);
		float mipInt = floor(mip);
		vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
		if (mipF == 0.0)
		{
			return vec4(color0, 1.0);
		}
		else
		{
			vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
			return vec4(mix(color0, color1, mipF), 1.0);
		}
	}
#endif
#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif
#ifdef USE_ENVMAP
	vec3 getIBLIrradiance(const in vec3 normal)
	{
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
			vec4 envMapColor = textureCubeUV(envMap, envMapRotation * worldNormal, 1.0);
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3(0.0);
		#endif
	}
	vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness)
	{
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect(-viewDir, normal);
			reflectVec = normalize(mix(reflectVec, normal, roughness * roughness));
			reflectVec = inverseTransformDirection(reflectVec, viewMatrix);
			vec4 envMapColor = textureCubeUV(envMap, envMapRotation * reflectVec, roughness);
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3(0.0);
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy)
		{
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross(bitangent, viewDir);
				bentNormal = normalize(cross(bentNormal, bitangent));
				bentNormal = normalize(mix(bentNormal, normal, pow2(pow2(1.0 - anisotropy * (1.0 - roughness)))));
				return getIBLRadiance(viewDir, bentNormal, roughness);
			#else
				return vec3(0.0);
			#endif
		}
	#endif
#endif
#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined(USE_LIGHT_PROBES)
	uniform vec3 lightProbe[9];
#endif
vec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9])
{
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[0] * 0.886227;
	result += shCoefficients[1] * 2.0 * 0.511664 * y;
	result += shCoefficients[2] * 2.0 * 0.511664 * z;
	result += shCoefficients[3] * 2.0 * 0.511664 * x;
	result += shCoefficients[4] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[5] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[6] * (0.743125 * z * z - 0.247708);
	result += shCoefficients[7] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[8] * 0.429043 * (x * x - y * y);
	return result;
}
vec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in vec3 normal)
{
	vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);
	vec3 irradiance = shGetIrradianceAt(worldNormal, lightProbe);
	return irradiance;
}
vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor)
{
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation(const in float lightDistance, const in float cutoffDistance, const in float decayExponent)
{
	float distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);
	if (cutoffDistance > 0.0)
	{
		distanceFalloff *= pow2(saturate(1.0 - pow4(lightDistance / cutoffDistance)));
	}
	return distanceFalloff;
}
float getSpotAttenuation(const in float coneCosine, const in float penumbraCosine, const in float angleCosine)
{
	return smoothstep(coneCosine, penumbraCosine, angleCosine);
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight
	{
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];
	void getDirectionalLightInfo(const in DirectionalLight directionalLight, out IncidentLight light)
	{
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight
	{
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[NUM_POINT_LIGHTS];
	void getPointLightInfo(const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light)
	{
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize(lVector);
		float lightDistance = length(lVector);
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation(lightDistance, pointLight.distance, pointLight.decay);
		light.visible = (light.color != vec3(0.0));
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight
	{
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[NUM_SPOT_LIGHTS];
	void getSpotLightInfo(const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light)
	{
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize(lVector);
		float angleCos = dot(light.direction, spotLight.direction);
		float spotAttenuation = getSpotAttenuation(spotLight.coneCos, spotLight.penumbraCos, angleCos);
		if (spotAttenuation > 0.0)
		{
			float lightDistance = length(lVector);
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation(lightDistance, spotLight.distance, spotLight.decay);
			light.visible = (light.color != vec3(0.0));
		}
		else
		{
			light.color = vec3(0.0);
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight
	{
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;
	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight
	{
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];
	vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in vec3 normal)
	{
		float dotNL = dot(normal, hemiLight.direction);
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);
		return irradiance;
	}
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
struct CustomSpecularMaterial
{
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
};
vec3 clearcoatSpecularDirect = vec3(0.0);
vec3 clearcoatSpecularIndirect = vec3(0.0);
vec3 sheenSpecularDirect = vec3(0.0);
vec3 sheenSpecularIndirect = vec3(0.0);
vec3 Schlick_to_F0(const in vec3 f, const in float f90, const in float dotVH)
{
	float x = clamp(1.0 - dotVH, 0.0, 1.0);
	float x2 = x * x;
	float x5 = clamp(x * x2 * x2, 0.0, 0.9999);
	return (f - vec3(f90) * x5) / (1.0 - x5);
}
float V_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV)
{
	float a2 = pow2(alpha);
	float gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));
	float gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));
	return 0.5 / max(gv + gl, EPSILON);
}
float D_GGX(const in float alpha, const in float dotNH)
{
	float a2 = pow2(alpha);
	float denom = pow2(dotNH) * (a2 - 1.0) + 1.0;
	return RECIPROCAL_PI * a2 / pow2(denom);
}
vec3 BRDF_GGX(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in CustomSpecularMaterial material)
{
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2(roughness);
	vec3 halfDir = normalize(lightDir + viewDir);
	float dotNL = saturate(dot(normal, lightDir));
	float dotNV = saturate(dot(normal, viewDir));
	float dotNH = saturate(dot(normal, halfDir));
	float dotVH = saturate(dot(viewDir, halfDir));
	vec3 F = F_Schlick(f0, f90, dotVH);
	#ifdef USE_IRIDESCENCE
		F = mix(F, material.iridescenceFresnel, material.iridescence);
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot(material.anisotropyT, lightDir);
		float dotTV = dot(material.anisotropyT, viewDir);
		float dotTH = dot(material.anisotropyT, halfDir);
		float dotBL = dot(material.anisotropyB, lightDir);
		float dotBV = dot(material.anisotropyB, viewDir);
		float dotBH = dot(material.anisotropyB, halfDir);
		float V = V_GGX_SmithCorrelated_Anisotropic(material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL);
		float D = D_GGX_Anisotropic(material.alphaT, alpha, dotNH, dotTH, dotBH);
	#else
		float V = V_GGX_SmithCorrelated(alpha, dotNL, dotNV);
		float D = D_GGX(alpha, dotNH);
	#endif
	return F * (V * D);
}
vec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness)
{
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate(dot(N, V));
	vec2 uv = vec2(roughness, sqrt(1.0 - dotNV));
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor(const in vec3 f)
{
	float l = length(f);
	return max((l * l + f.z) / (l + 1.0), 0.0);
}
vec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2)
{
	float x = dot(v1, v2);
	float y = abs(x);
	float a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;
	float b = 3.4175940 + (4.1616724 + y) * y;
	float v = a / b;
	float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;
	return cross(v1, v2) * theta_sintheta;
}
vec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4])
{
	vec3 v1 = rectCoords[1] - rectCoords[0];
	vec3 v2 = rectCoords[3] - rectCoords[0];
	vec3 lightNormal = cross(v1, v2);
	if (dot(lightNormal, P - rectCoords[0]) < 0.0)
	return vec3(0.0);
	vec3 T1, T2;
	T1 = normalize(V - N * dot(V, N));
	T2 = -cross(N, T1);
	mat3 mat = mInv * transposeMat3(mat3(T1, T2, N));
	vec3 coords[4];
	coords[0] = mat * (rectCoords[0] - P);
	coords[1] = mat * (rectCoords[1] - P);
	coords[2] = mat * (rectCoords[2] - P);
	coords[3] = mat * (rectCoords[3] - P);
	coords[0] = normalize(coords[0]);
	coords[1] = normalize(coords[1]);
	coords[2] = normalize(coords[2]);
	coords[3] = normalize(coords[3]);
	vec3 vectorFormFactor = vec3(0.0);
	vectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);
	vectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);
	vectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);
	vectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);
	float result = LTC_ClippedSphereFormFactor(vectorFormFactor);
	return vec3(result);
}
float IBLSheenBRDF(const in vec3 normal, const in vec3 viewDir, const in float roughness)
{
	float dotNV = saturate(dot(normal, viewDir));
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp(a * dotNV + b) + (roughness < 0.25 ? 0.0 : 0.1 * (roughness - 0.25));
	return saturate(DG * RECIPROCAL_PI);
}
vec2 DFGApprox(const in vec3 normal, const in vec3 viewDir, const in float roughness)
{
	float dotNV = saturate(dot(normal, viewDir));
	const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
	const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
	vec4 r = roughness * c0 + c1;
	float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;
	vec2 fab = vec2(-1.04, 1.04) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness)
{
	vec2 fab = DFGApprox(normal, viewDir, roughness);
	return specularColor * fab.x + specularF90 * fab.y;
}

void computeMultiscattering(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter)
{
	vec2 fab = DFGApprox(normal, viewDir, roughness);
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix(specularColor, iridescenceF0, iridescence);
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + (1.0 - Fr) * 0.047619;
	vec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in CustomSpecularMaterial material, inout ReflectedLight reflectedLight)
	{
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[4];
		rectCoords[0] = lightPos + halfWidth - halfHeight;
		rectCoords[1] = lightPos - halfWidth - halfHeight;
		rectCoords[2] = lightPos - halfWidth + halfHeight;
		rectCoords[3] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv(normal, viewDir, roughness);
		vec4 t1 = texture2D(ltc_1, uv);
		vec4 t2 = texture2D(ltc_2, uv);
		mat3 mInv = mat3(
		vec3(t1.x, 0, t1.y),
		vec3(0, 1, 0),
		vec3(t1.z, 0, t1.w));
		vec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);
	}
#endif
void RE_Direct_Physical(const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in CustomSpecularMaterial material, inout ReflectedLight reflectedLight)
{
	float dotNL = saturate(dot(geometryNormal, directLight.direction));
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate(dot(geometryClearcoatNormal, directLight.direction));
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat(directLight.direction, geometryViewDir, geometryClearcoatNormal, material);
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen(directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness);
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometryViewDir, geometryNormal, material);
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in CustomSpecularMaterial material, inout ReflectedLight reflectedLight)
{
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}
void RE_IndirectSpecular_Physical(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in CustomSpecularMaterial material, inout ReflectedLight reflectedLight)
{
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF(geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness);
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF(geometryNormal, geometryViewDir, material.sheenRoughness);
	#endif
	vec3 singleScattering = vec3(0.0);
	vec3 multiScattering = vec3(0.0);
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence(geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering);
	#else
		computeMultiscattering(geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering);
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * (1.0 - max(max(totalScattering.r, totalScattering.g), totalScattering.b));
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct RE_Direct_Physical
#define RE_Direct_RectArea RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular RE_IndirectSpecular_Physical
float computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness)
{
	return saturate(pow(dotNV + ambientOcclusion, exp2(-16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);
}
#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[NUM_SPOT_LIGHT_COORDS];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[NUM_SPOT_LIGHT_MAPS];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];
		varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];
		struct DirectionalLightShadow
		{
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];
		struct SpotLightShadow
		{
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];
		varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];
		struct PointLightShadow
		{
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
	#endif
	float texture2DCompare(sampler2D depths, vec2 uv, float compare)
	{
		return step(compare, unpackRGBAToDepth(texture2D(depths, uv)));
	}
	vec2 texture2DDistribution(sampler2D shadow, vec2 uv)
	{
		return unpackRGBATo2Half(texture2D(shadow, uv));
	}
	float VSMShadow(sampler2D shadow, vec2 uv, float compare)
	{
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution(shadow, uv);
		float hard_shadow = step(compare, distribution.x);
		if (hard_shadow != 1.0)
		{
			float distance = compare - distribution.x;
			float variance = max(0.00000, distribution.y * distribution.y);
			float softness_probability = variance / (variance + distance * distance);
			softness_probability = clamp((softness_probability - 0.3) / (0.95 - 0.3), 0.0, 1.0);
			occlusion = clamp(max(hard_shadow, softness_probability), 0.0, 1.0);
		}
		return occlusion;
	}
	float getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord)
	{
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if (frustumTest)
		{
			#if defined(SHADOWMAP_TYPE_PCF)
				vec2 texelSize = vec2(1.0) / shadowMapSize;
				float dx0 = -texelSize.x * shadowRadius;
				float dy0 = -texelSize.y * shadowRadius;
				float dx1 = +texelSize.x * shadowRadius;
				float dy1 = +texelSize.y * shadowRadius;
				float dx2 = dx0 / 2.0;
				float dy2 = dy0 / 2.0;
				float dx3 = dx1 / 2.0;
				float dy3 = dy1 / 2.0;
				shadow = (texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx2, dy2), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy2), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx3, dy2), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, 0.0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx2, 0.0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx3, 0.0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, 0.0), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx2, dy3), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy3), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx3, dy3), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy1), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy1), shadowCoord.z) +
				texture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy1), shadowCoord.z)) *
				(1.0 / 17.0);
			#elif defined(SHADOWMAP_TYPE_PCF_SOFT)
				vec2 texelSize = vec2(1.0) / shadowMapSize;
				float dx = texelSize.x;
				float dy = texelSize.y;
				vec2 uv = shadowCoord.xy;
				vec2 f = fract(uv * shadowMapSize + 0.5);
				uv -= f * texelSize;
				shadow = (texture2DCompare(shadowMap, uv, shadowCoord.z) +
				texture2DCompare(shadowMap, uv + vec2(dx, 0.0), shadowCoord.z) +
				texture2DCompare(shadowMap, uv + vec2(0.0, dy), shadowCoord.z) +
				texture2DCompare(shadowMap, uv + texelSize, shadowCoord.z) +
				mix(texture2DCompare(shadowMap, uv + vec2(-dx, 0.0), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(2.0 * dx, 0.0), shadowCoord.z),
				f.x) +
				mix(texture2DCompare(shadowMap, uv + vec2(-dx, dy), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(2.0 * dx, dy), shadowCoord.z),
				f.x) +
				mix(texture2DCompare(shadowMap, uv + vec2(0.0, -dy), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(0.0, 2.0 * dy), shadowCoord.z),
				f.y) +
				mix(texture2DCompare(shadowMap, uv + vec2(dx, -dy), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(dx, 2.0 * dy), shadowCoord.z),
				f.y) +
				mix(mix(texture2DCompare(shadowMap, uv + vec2(-dx, -dy), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(2.0 * dx, -dy), shadowCoord.z),
				f.x),
				mix(texture2DCompare(shadowMap, uv + vec2(-dx, 2.0 * dy), shadowCoord.z),
				texture2DCompare(shadowMap, uv + vec2(2.0 * dx, 2.0 * dy), shadowCoord.z),
				f.x),
				f.y)) *
				(1.0 / 9.0);
			#elif defined(SHADOWMAP_TYPE_VSM)
				shadow = VSMShadow(shadowMap, shadowCoord.xy, shadowCoord.z);
			#else
				shadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);
			#endif
		}
		return mix(1.0, shadow, shadowIntensity);
	}
	vec2 cubeToUV(vec3 v, float texelSizeY)
	{
		vec3 absV = abs(v);
		float scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));
		absV *= scaleToCube;
		v *= scaleToCube * (1.0 - 2.0 * texelSizeY);
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if (absV.z >= almostOne)
		{
			if (v.z > 0.0)
			planar.x = 4.0 - v.x;
		}
		else if (absV.x >= almostOne)
		{
			float signX = sign(v.x);
			planar.x = v.z * signX + 2.0 * signX;
		}
		else if (absV.y >= almostOne)
		{
			float signY = sign(v.y);
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);
	}
	float getPointShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar)
	{
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;

		float lightToPositionLength = length(lightToPosition);
		if (lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0)
		{
			float dp = (lightToPositionLength - shadowCameraNear) / (shadowCameraFar - shadowCameraNear);
			dp += shadowBias;
			vec3 bd3D = normalize(lightToPosition);
			vec2 texelSize = vec2(1.0) / (shadowMapSize * vec2(4.0, 2.0));
			#if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT) || defined(SHADOWMAP_TYPE_VSM)
				vec2 offset = vec2(-1, 1) * shadowRadius * texelSize.y;
				shadow = (texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyy, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyy, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyx, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyx, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxy, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxy, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxx, texelSize.y), dp) +
				texture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxx, texelSize.y), dp)) *
				(1.0 / 9.0);
			#else
				shadow = texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);
			#endif
		}
		return mix(1.0, shadow, shadowIntensity);
	}
#endif

#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd()
	{
		vec2 dSTdx = dFdx(vBumpMapUv);
		vec2 dSTdy = dFdy(vBumpMapUv);
		float Hll = bumpScale * texture2D(bumpMap, vBumpMapUv).x;
		float dBx = bumpScale * texture2D(bumpMap, vBumpMapUv + dSTdx).x - Hll;
		float dBy = bumpScale * texture2D(bumpMap, vBumpMapUv + dSTdy).x - Hll;
		return vec2(dBx, dBy);
	}
	vec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection)
	{
		vec3 vSigmaX = normalize(dFdx(surf_pos.xyz));
		vec3 vSigmaY = normalize(dFdy(surf_pos.xyz));
		vec3 vN = surf_norm;
		vec3 R1 = cross(vSigmaY, vN);
		vec3 R2 = cross(vN, vSigmaX);
		float fDet = dot(vSigmaX, R1) * faceDirection;
		vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);
		return normalize(abs(fDet) * surf_norm - vGrad);
	}
#endif
#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if !defined(USE_TANGENT) && (defined(USE_NORMALMAP_TANGENTSPACE) || defined(USE_CLEARCOAT_NORMALMAP) || defined(USE_ANISOTROPY))
	mat3 getTangentFrame(vec3 eye_pos, vec3 surf_norm, vec2 uv)
	{
		vec3 q0 = dFdx(eye_pos.xyz);
		vec3 q1 = dFdy(eye_pos.xyz);
		vec2 st0 = dFdx(uv.st);
		vec2 st1 = dFdy(uv.st);
		vec3 N = surf_norm;
		vec3 q1perp = cross(q1, N);
		vec3 q0perp = cross(N, q0);
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max(dot(T, T), dot(B, B));
		float scale = (det == 0.0) ? 0.0 : inversesqrt(det);
		return mat3(T * scale, B * scale, N);
	}
#endif

#if defined(USE_LOGDEPTHBUF)
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif

#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];
#endif

void main()
{

	vec4 diffuseColor = vec4(diffuse, opacity);
	#if NUM_CLIPPING_PLANES > 0
		vec4 plane;
		#ifdef ALPHA_TO_COVERAGE
			float distanceToPlane, distanceGradient;
			float clipOpacity = 1.0;
			#pragma unroll_loop_start
			for (int i = 0; i < UNION_CLIPPING_PLANES; i++)
			{
				plane = clippingPlanes[i];
				distanceToPlane = -dot(vClipPosition, plane.xyz) + plane.w;
				distanceGradient = fwidth(distanceToPlane) / 2.0;
				clipOpacity *= smoothstep(-distanceGradient, distanceGradient, distanceToPlane);
				if (clipOpacity == 0.0)
				discard;
			}
			#pragma unroll_loop_end
			#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
				float unionClipOpacity = 1.0;
				#pragma unroll_loop_start
				for (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++)
				{
					plane = clippingPlanes[i];
					distanceToPlane = -dot(vClipPosition, plane.xyz) + plane.w;
					distanceGradient = fwidth(distanceToPlane) / 2.0;
					unionClipOpacity *= 1.0 - smoothstep(-distanceGradient, distanceGradient, distanceToPlane);
				}
				#pragma unroll_loop_end
				clipOpacity *= 1.0 - unionClipOpacity;
			#endif
			diffuseColor.a *= clipOpacity;
			if (diffuseColor.a == 0.0)
			discard;
		#else
			#pragma unroll_loop_start
			for (int i = 0; i < UNION_CLIPPING_PLANES; i++)
			{
				plane = clippingPlanes[i];
				if (dot(vClipPosition, plane.xyz) > plane.w)
				discard;
			}
			#pragma unroll_loop_end
			#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
				bool clipped = true;
				#pragma unroll_loop_start
				for (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++)
				{
					plane = clippingPlanes[i];
					clipped = (dot(vClipPosition, plane.xyz) > plane.w) && clipped;
				}
				#pragma unroll_loop_end
				if (clipped)
				discard;
			#endif
		#endif
	#endif

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
	vec3 totalEmissiveRadiance = emissive;

	#if defined(USE_LOGDEPTHBUF)
		gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;
	#endif
	#ifdef USE_MAP
		vec4 sampledDiffuseColor = texture2D(map, vMapUv);
		#ifdef DECODE_VIDEO_TEXTURE
			sampledDiffuseColor = vec4(mix(pow(sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(sampledDiffuseColor.rgb, vec3(0.04045)))), sampledDiffuseColor.w);

		#endif
		diffuseColor *= sampledDiffuseColor;
	#endif
	#if defined(USE_COLOR_ALPHA)
		diffuseColor *= vColor;
	#elif defined(USE_COLOR)
		diffuseColor.rgb *= vColor;
	#endif
	#ifdef USE_ALPHAMAP
		diffuseColor.a *= texture2D(alphaMap, vAlphaMapUv).g;
	#endif
	#ifdef USE_ALPHATEST
		#ifdef ALPHA_TO_COVERAGE
			diffuseColor.a = smoothstep(alphaTest, alphaTest + fwidth(diffuseColor.a), diffuseColor.a);
			if (diffuseColor.a == 0.0)
			discard;
		#else
			if (diffuseColor.a < alphaTest)
			discard;
		#endif
	#endif
	#ifdef USE_ALPHAHASH
		if (diffuseColor.a < getAlphaHashThreshold(vPosition))
		discard;
	#endif
	float roughnessFactor = roughness;

	vec4 texelRoughness = vec4(1.0) - texture2D(glossinessMap, vRoughnessMapUv);
	roughnessFactor *= texelRoughness.g;

	float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

	float reflectionFactor = specularValue;
	vec3 reflectionColor = texture2D(specularMap, vUv).rgb; // Карта REFLECTION
	reflectionFactor *= reflectionColor.b;

	#ifdef FLAT_SHADED
		vec3 fdx = dFdx(vViewPosition);
		vec3 fdy = dFdy(vViewPosition);
		vec3 normal = normalize(cross(fdx, fdy));
	#else
		vec3 normal = normalize(vNormal);
		#ifdef DOUBLE_SIDED
			normal *= faceDirection;
		#endif
	#endif

	#if defined(USE_NORMALMAP_TANGENTSPACE) || defined(USE_CLEARCOAT_NORMALMAP) || defined(USE_ANISOTROPY)
		#ifdef USE_TANGENT
			mat3 tbn = mat3(normalize(vTangent), normalize(vBitangent), normal);
		#else
			mat3 tbn = getTangentFrame(-vViewPosition, normal,
			#if defined(USE_NORMALMAP)
				vNormalMapUv
			#elif defined(USE_CLEARCOAT_NORMALMAP)
				vClearcoatNormalMapUv
			#else
				vUv
			#endif
			);
		#endif
		#if defined(DOUBLE_SIDED) && !defined(FLAT_SHADED)
			tbn[0] *= faceDirection;
			tbn[1] *= faceDirection;
		#endif
	#endif

	vec3 nonPerturbedNormal = normal;
	#ifdef USE_NORMALMAP_OBJECTSPACE
		normal = texture2D(normalMap, vNormalMapUv).xyz * 2.0 - 1.0;
		#ifdef FLIP_SIDED
			normal = -normal;
		#endif
		#ifdef DOUBLE_SIDED
			normal = normal * faceDirection;
		#endif
		normal = normalize(normalMatrix * normal);
	#elif defined(USE_NORMALMAP_TANGENTSPACE)
		vec3 mapN = texture2D(normalMap, vNormalMapUv).xyz * 2.0 - 1.0;
		mapN.xy *= normalScale;
		normal = normalize(tbn * mapN);
	#elif defined(USE_BUMPMAP)
		normal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd(), faceDirection);
	#endif

	#ifdef USE_EMISSIVEMAP
		vec4 emissiveColor = texture2D(emissiveMap, vEmissiveMapUv);
		totalEmissiveRadiance *= emissiveColor.rgb;
	#endif

	// accumulation
	CustomSpecularMaterial material;
	material.diffuseColor = diffuseColor.rgb * (1.0-reflectionFactor);
	// material.diffuseColor = diffuseColor.rgb;
	vec3 dxy = max(abs(dFdx(nonPerturbedNormal)), abs(dFdy(nonPerturbedNormal)));
	float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
	material.roughness = max(roughnessFactor, 0.0525);
	material.roughness += geometryRoughness;
	material.roughness = min(material.roughness, 1.0);

	// material.specularColor = mix(vec3(0.04), diffuseColor.rgb, metalnessFactor);
	// material.specularColor = mix(vec3(0.04), diffuseColor.rgb, texelRoughness.rgb);
	material.specularColor = reflectionColor.rgb;
	material.specularF90 = 1.0;

	vec3 geometryPosition = -vViewPosition;
	vec3 geometryNormal = normal;
	vec3 geometryViewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);
	vec3 geometryClearcoatNormal = vec3(0.0);

	IncidentLight directLight;
	#if (NUM_POINT_LIGHTS > 0) && defined(RE_Direct)
		PointLight pointLight;
		#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0
			PointLightShadow pointLightShadow;
		#endif
		#pragma unroll_loop_start
		for (int i = 0; i < NUM_POINT_LIGHTS; i++)
		{
			pointLight = pointLights[i];
			getPointLightInfo(pointLight, geometryPosition, directLight);
			#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
				pointLightShadow = pointLightShadows[i];
				directLight.color *= (directLight.visible && receiveShadow) ? getPointShadow(pointShadowMap[i], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[i], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar) : 1.0;
			#endif
			RE_Direct(directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
		}
		#pragma unroll_loop_end
	#endif
	#if (NUM_SPOT_LIGHTS > 0) && defined(RE_Direct)
		SpotLight spotLight;
		vec4 spotColor;
		vec3 spotLightCoord;
		bool inSpotLightMap;
		#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0
			SpotLightShadow spotLightShadow;
		#endif
		#pragma unroll_loop_start
		for (int i = 0; i < NUM_SPOT_LIGHTS; i++)
		{
			spotLight = spotLights[i];
			getSpotLightInfo(spotLight, geometryPosition, directLight);
			#if (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS)
				#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
			#elif (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
				#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
			#else
				#define SPOT_LIGHT_MAP_INDEX (UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS)
			#endif
			#if (SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS)
				spotLightCoord = vSpotLightCoord[i].xyz / vSpotLightCoord[i].w;
				inSpotLightMap = all(lessThan(abs(spotLightCoord * 2. - 1.), vec3(1.0)));
				spotColor = texture2D(spotLightMap[SPOT_LIGHT_MAP_INDEX], spotLightCoord.xy);
				directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
			#endif
			#undef SPOT_LIGHT_MAP_INDEX
			#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
				spotLightShadow = spotLightShadows[i];
				directLight.color *= (directLight.visible && receiveShadow) ? getShadow(spotShadowMap[i], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[i]) : 1.0;
			#endif
			RE_Direct(directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
		}
		#pragma unroll_loop_end
	#endif
	#if (NUM_DIR_LIGHTS > 0) && defined(RE_Direct)
		DirectionalLight directionalLight;
		#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0
			DirectionalLightShadow directionalLightShadow;
		#endif
		#pragma unroll_loop_start
		for (int i = 0; i < NUM_DIR_LIGHTS; i++)
		{
			directionalLight = directionalLights[i];
			getDirectionalLightInfo(directionalLight, directLight);
			#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
				directionalLightShadow = directionalLightShadows[i];
				directLight.color *= (directLight.visible && receiveShadow) ? getShadow(directionalShadowMap[i], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[i]) : 1.0;
			#endif
			RE_Direct(directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
		}
		#pragma unroll_loop_end
	#endif
	#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)
		RectAreaLight rectAreaLight;
		#pragma unroll_loop_start
		for (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++)
		{
			rectAreaLight = rectAreaLights[i];
			RE_Direct_RectArea(rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
		}
		#pragma unroll_loop_end
	#endif
	#if defined(RE_IndirectDiffuse)
		vec3 iblIrradiance = vec3(0.0);
		vec3 irradiance = getAmbientLightIrradiance(ambientLightColor);
		#if defined(USE_LIGHT_PROBES)
			irradiance += getLightProbeIrradiance(lightProbe, geometryNormal);
		#endif
		#if (NUM_HEMI_LIGHTS > 0)
			#pragma unroll_loop_start
			for (int i = 0; i < NUM_HEMI_LIGHTS; i++)
			{
				irradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometryNormal);
			}
			#pragma unroll_loop_end
		#endif
	#endif
	#if defined(RE_IndirectSpecular)
		vec3 radiance = vec3(0.0);
		vec3 clearcoatRadiance = vec3(0.0);
	#endif
	#if defined(RE_IndirectDiffuse)
		#ifdef USE_LIGHTMAP
			vec4 lightMapTexel = texture2D(lightMap, vLightMapUv);
			vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
			irradiance += lightMapIrradiance;
		#endif
		#if defined(USE_ENVMAP) && defined(STANDARD) && defined(ENVMAP_TYPE_CUBE_UV)
			iblIrradiance += getIBLIrradiance(geometryNormal);
		#endif
	#endif
	#if defined(USE_ENVMAP) && defined(RE_IndirectSpecular)
		#ifdef USE_ANISOTROPY
			radiance += getIBLAnisotropyRadiance(geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy);
		#else
			radiance += getIBLRadiance(geometryViewDir, geometryNormal, material.roughness);
		#endif
		#ifdef USE_CLEARCOAT
			clearcoatRadiance += getIBLRadiance(geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness);
		#endif
	#endif
	#if defined(RE_IndirectDiffuse)
		RE_IndirectDiffuse(irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
	#endif
	#if defined(RE_IndirectSpecular)
		RE_IndirectSpecular(radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight);
	#endif

	// modulation
	#ifdef USE_AOMAP
		float ambientOcclusion = (texture2D(aoMap, vAoMapUv).r - 1.0) * aoMapIntensity + 1.0;
		reflectedLight.indirectDiffuse *= ambientOcclusion;
		#if defined(USE_CLEARCOAT)
			clearcoatSpecularIndirect *= ambientOcclusion;
		#endif
		#if defined(USE_SHEEN)
			sheenSpecularIndirect *= ambientOcclusion;
		#endif
		#if defined(USE_ENVMAP) && defined(STANDARD)
			float dotNV = saturate(dot(geometryNormal, geometryViewDir));
			reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.roughness);
		#endif
	#endif

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef OPAQUE
		diffuseColor.a = 1.0;
	#endif
	gl_FragColor = vec4(outgoingLight, diffuseColor.a);
	#if defined(TONE_MAPPING)
		gl_FragColor.rgb = toneMapping(gl_FragColor.rgb);
	#endif
	gl_FragColor = linearToOutputTexel(gl_FragColor);
	#ifdef USE_FOG
		#ifdef FOG_EXP2
			float fogFactor = 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth);
		#else
			float fogFactor = smoothstep(fogNear, fogFar, vFogDepth);
		#endif
		gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);
	#endif
	#ifdef PREMULTIPLIED_ALPHA
		gl_FragColor.rgb *= gl_FragColor.a;
	#endif
	#ifdef DITHERING
		gl_FragColor.rgb = dithering(gl_FragColor.rgb);
	#endif

	// vec4 diffuseColor = texture2D(map, vUv); // Карта COL
	// vec3 reflectionColor = texture2D(specularMap, vUv).rgb; // Карта REFLECTION
	// float glossiness = texture2D(glossinessMap, vUv).r; // Карта GLOSSINESS
	// vec3 finalColor = diffuseColor.rgb + reflectionColor * glossiness;
	// gl_FragColor = vec4(finalColor, 1.0);
}